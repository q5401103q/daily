关于Base64和TripleDES的学习心得
==================================================
Base64
--------------------------------------------------
  Base64是一种用于传输的编码方式（6bit可满足[0,63]的区间要求），最终的Base64编码（摘自RFC2045）如下：<br>

  The Base64 Alphabet<br>
    * 索引0-25对应字节A-Z<br>
    * 索引26-51对应字节a-z<br>
    * 索引52-61对应字节0-9<br>
    * 索引62对应字节+<br>
    * 索引63对应字节/<br>

  假设有下面的代码：<br>
```C# Sample Code
[TestMethod]
public void TestMethod()
{
  //Base64String
  string str = "00000000"; 
  //将Base64String转为byte数组
  byte[] result = Convert.FromBase64String(str);
  //将byte数组转换符字符数组
  char[] c = Encoding.ASCII.GetChars(result);
  //转为Unicode
  string s = new String(c);
  //断言
  Assert.AreEqual(s, "?M4?M4");
}
```
  查询Table1可知'0'对应的索引是52，用二进制的形式表示就是110100，即str为：
```
110100,110100,110100,110100,110100,110100,110100,110100
```
  经过转换后,每8个字节构成一个byte,因此result为：
```
11010011,01001101,00110100,11010011,01001101,00110100
```
  对应的十进制为：
```
211,77,52,211,77,52
```
  查询ASCII码表发现77是'M'，52是'4'，211超过了127，在C#代码中，无法用ASCII码表示，故为乱码的'?'，因此char数组c的结果是：
```
'?','M','4','?','M','4'
```
  最终的字符串是"?M4?M4"，最终的断言是true<br>
  同理，将字符串转换为Base64String的时候过程相反。

关于TripleDES的加密和解密过程
--------------------------------------------------
  设Ek()和Dk()分别代表DES算法的加密和解密过程，k代表DES算法使用的密钥，M代表明文，C代表密文，则3DES算法的过程可表示为：<br>
    * 加密：C = Ek3(Dk2(Ek1(M))) 即对明文数据进行 加密 --> 解密 --> 加密的过程，最后得到密文数据
    * 解密：M = Dk1(Ek2(Dk3(C))) 即对密文数据进行 解密 --> 加密 --> 解密的过程，最后得到明文数据
  
  这里可以K1=K3，但不能K1=K2=K3（如果相等的话就成了DES算法了）<br>
  Kn密钥是8byte，但实际上只有7个用上，也就是56bit。因此TripleDES就是21个字母或数字符号，加上不用的字节，最终的长度应该是24byte。<br>

  长度为32byte的GUID经过Base64String转换，变为长度为24的byte数组，然后将密钥分为3段8byte的密钥分别为密钥1、密钥2、密钥3。<br>
    * 在TripleDES加密时，对加密解密加密依次使用密钥1、密钥2、密钥3
    * 在TripleDES解密时，对解密加密解密依次使用密钥3、密钥2、密钥1

  CBC模式也需要将待处理的数据分块，但是每一块数据在加密或者解密之前都要与前一块的结果做一次异或操作。<br>
  因此该模式需要定义一个特殊的8字节Key，用于和第一块数据做异或操作，这个特殊的Key就是通常说的初始化向量IV。<br>
